{"name":"Lamdu","tagline":"Lamdu - towards the next generation IDE","body":"# Project Lamdu\r\n\r\nThis project aims to create a \"next-generation\", \"live programming\" environment that radically improves the programming experience.\r\n\r\nThe main idea behind the Lamdu project is that the canonical representation of programs should not be text, but rich data structures: Abstract syntax trees.\r\n\r\nOur programming tools, UIs and ecosystems should take advantage and expose this structure. This has some far-reaching implications, which will be described below.\r\n\r\n## Programming Language\r\n\r\nWe believe the Haskell language is a great language for rapid development of reliable programs, due to 2 main traits:\r\n\r\n### Effect typing\r\n\r\nHaskell has explicit type-level separation of effectful components from pure components.\r\nReal Haskell programs demonstrate that the majority of code can be written as pure components.\r\nThis allows a live environment to actually execute code as it is being edited, safely, and bring the benefits of spreadsheets to general purpose programming.\r\n\r\n### Rich and powerful type system\r\n\r\nHaskell has one of the richest and most powerful type systems, which allows a smart IDE to guide the programmer quickly through the space of type-correct programs. In practice, this reduces much of the cognitive burden of writing programs and the number of input gestures/keystrokes required to write or edit programs.\r\n\r\n### Why not Haskell\r\n\r\nHaskell was designed for textual editing. The Programming Language for Lamdu is optimized for rich structural editing.\r\n\r\nTherefore, Lamdu implements a programming language very similar to Haskell, with some modifications.\r\n\r\n#### Explicit argument names\r\n\r\nIn order to present explicit argument names for most function applications, records are used for conventional parameters. This means that the Lamdu programming language does not conventionally use currying. Haskell's use of currying affords very concise notation for partial function application, which is a wonderful feature. In a rich IDE, however, partial application can be visualized and edited concisely without currying.\r\n\r\n#### Explicit type variables\r\n\r\nHaskell, like most Hindley Milner languages, hides the type-variable lambdas from types and type variable applications/instantiations in use-sites. In Lamdu, the same hiding can be done at the UI level, while making the underlying language simpler. It also allows explicitly specifying type variable instantiations in a simple way.\r\n\r\n#### Structural type system\r\n\r\nThis isn't strictly about the textual paradigm, but we believe that a structural type system (with anonymous products and sums) should help providing more precise types for intermediate expressions, leveraging the type system more powerfully.\r\n\r\n## Lamdu Benefits\r\n\r\n### No Syntax errors\r\n\r\nEditing programs as rich structures means there are no syntax errors\r\n\r\n### Incremental type errors\r\n\r\nType errors are incremental, meaning that type information available form previous, valid states of the program is available to provide better, more localized type errors.\r\n\r\nIncremental type checking is much cheaper than full recompilation as featured by mainstream IDE's, allowing a snappy experience.\r\n\r\nType error feedback is immediate, while the edit is still fresh in the programmer's mind.\r\n\r\nType errors are confined and localized to the sub-expression involved, made simple and comprehensible.\r\n\r\nType information is not lost when type errors exist, allowing the IDE to guide the programmer in resolving type errors intelligently.\r\n\r\n### Better completions\r\n\r\nWhen types are rich enough, much of the program structure can be inferred from the types.\r\n\r\nThis affords significantly more powerful and intelligent completions than found in mainstream IDE's.\r\n\r\n### Live execution\r\n\r\nFrees the programmer from having to trace code execution in their head.\r\n\r\nDebugging pure code means expanding sub-expressions that have the wrong result, and following through the sub-expressions that contain the mistakes. This should be a much easier experience than stepping through code.\r\n\r\n### Safe refactoring\r\n\r\nThe IDE has much stronger guarantees about the meaning and structure of the code. This allows refactoring to be *completely* safe.\r\n\r\nSafe refactoring allows programmers to keep the code tidy, without fear of regressions.\r\n\r\n### Better Collaboration\r\n\r\nOne of the most difficult things about collaborative development is handling merge conflicts.\r\n\r\nThe vast majority of merge conflicts are results of non-functional changes: Renames, reformatting, textual movement of code lines between files, etc.\r\n\r\nIn Lamdu, \"names\", the \"position\" of the code and other non-functional aspects of code are separate from the code itself, and avoid conflicts.\r\n\r\n#### Rename conflicts\r\n\r\nTo get a conflict due to \"rename\" operations, two developers must rename the same variable to two different names. Even then, the code is still executable, but its on-screen rendering will display a localized conflict.\r\n\r\n#### Formatting conflicts\r\n\r\nFormatting is automatic, so there is no way to generate a conflict.\r\n\r\n#### Code movement conflicts\r\n\r\nThe \"position\" of code is meta-data attached to the code, helping to find that code and position its rendering.\r\n\r\nSince code is not structured into text files, code \"position\" conflicts are similarly less harmful, less likely and localized.\r\n\r\n#### Change tracking\r\n\r\nInstead of heuristically guessing what changed in the code, as traditional version control systems do, Lamdu uses an integrated revision control system and records the changes by the programmer as revisions.\r\n\r\nThis acts as a record of the developer's intent, allowing the RCS to distinguish, for example, between function deletion and writing of a similar function, and the modification of that same function.  This record of intent will be helpful in preventing and resolving conflicts later.\r\n\r\n### Bringing Haskell* to the masses\r\n\r\nWe believe the main thing that prevents the masses from using a Haskell-like language, is a difficult learning experience and lack of good tooling.\r\n\r\n#### Beginners\r\n\r\nBy removing syntax errors, having a discoverable set of valid program transformations, radically simplifying type errors, giving immediate feedback on editing and visualizing execution, learnability drastically improves.\r\n\r\n#### Experts\r\n\r\nBy creating a state-of-the-art, powerful IDE that out-rivals existing IDEs for mainstream languages, we can appeal to the experts, as well.\r\n\r\n### Regression Debugging\r\n\r\nIntegrated revision control and live test cases will allow \"Regression Debugging\".\r\n\r\nWhen a change causes a regression, the root of the problem can be found quickly, by finding the deepest function application whose result value diverged from the correct version of the code.\r\n\r\n### Automatic Formatting and Sugaring\r\n\r\nLamdu attempts to take away as much inconsequential freedom from the developer, to free his mind and his key strokes to deal with the parts that matter in the code. Thus, Lamdu does not provide means to edit formatting on a case-by-case basis. Generalized changes to layout rules can be provided, instead.\r\n\r\nAdditionally, to avoid further stylistic dillemas, Lamdu uses automatic sugaring of code, as a duel of the typical \"de-sugaring\" done by textual languages.\r\n\r\nThe code is edited and displayed in its sugared form. The edits to this form are translated to lower-level, simpler edits of the stored language, which is de-sugared.  Lamdu uses \"co-macros\" that capture patterns in the lower-level code and automatically sugar it to canonical form. This frees the programmer from worrying about whether to use sugar for each particular case.\r\n\r\n### Visualization\r\n\r\nTextual languages can have extensible syntax for rendering and parsing values of custom-defined data-types. A rich structural IDE can take this further, and allow defining extensible UI components to render and edit values of custom-defined data-types.\r\n\r\nIn effect, this allows for more powerful DSL extensions to the language. These DSLs are not just custom data-types and combinators, but also rich UIs with optimized key bindings to work with that DSL.\r\n\r\nFor example \"do notation\" can be implemented as a co-macro (see above) to capture the >>= to lambda syntactic form.  Then, a customized UI that edits the \"do notation\" sugared form can be provided, extending the language.\r\n\r\nSimilarly, a binary tree implemented may be edited with a rich UI that visualizes the trees. The inputs, outputs and subexpressions with tree-typed values will use such rich visualizations, instead of flat textual renderings.\r\n\r\n### Transparent build process\r\n\r\nToday's tools treat the compiler as an opaque, black box, which may or may not apply a set of optimizations to the source code, with great or catastrophic results. Some experts are aware of tooling options to display the intermediate steps in the compiler in an arcane, difficult-to-understand notation.\r\n\r\nWe intend to make the build process, including compilation, be an explicit pure transformation of the code into intermediate and final forms. The steps of this transformation can be visualized by the live programming environment similarly to the visualization of execution of all pure code.\r\n\r\nThis will allow far easier inspection of the optimization process, taking away much of the \"magic\" involved in getting optimizations to fire properly.\r\n\r\n# Similar Efforts\r\n\r\n## Inventing on Principle\r\n\r\nBret Victor presented amazing demos in his [inspiring talk in January 2012](http://vimeo.com/36579366).\r\n\r\n## Light Table\r\n\r\nInspired by Bret Victor, [Light Table](http://www.kickstarter.com/projects/ibdknox/light-table) by Chris Granger is an IDE for Clojure with a \"live coding\" REPL.\r\n\r\nChris launched the project at [Kickstarter](http://www.kickstarter.com/) at April 2012 and raised more than 300K$ for the project.\r\nSoon after Chris founded a company, [Kodowa](http://www.kodowa.com/), with Robert Attorri, which joined Y-Combinator's \"Summer 2012 batch\".\r\n\r\n## Projucer\r\n\r\n[Projucer](http://www.rawmaterialsoftware.com/viewtopic.php?f=12&t=9793) by Julian Storer (Jules), also inspired by Bret Victor, is a live programming IDE for C++ using the Juce cross-platform framework.\r\n\r\nIt integrates with [LLVM](http://llvm.org/)'s just-in-time compiler to provide fast compilation and advanced features similar to those in Bret Victor's demos. It aims to be a \"Light Table for 'Real Programmers'\".\r\n\r\nIt initially aims to provide live coding specifically to GUIs, but later for other uses, specifically uses in the Audio niches in which Jules and Juce focus on.\r\n\r\nThe project is not open source and is planned to be a commercial IDE.\r\n\r\nThe project launched at September 2012, and as of October, Jules said he'll be release an alpha version soon.\r\n\r\n## Subtext\r\n\r\n[Subtext](http://subtextual.org/) by Jonathan Edwards is a similar effort from 2004.\r\n\r\nIn his [Subtext 1](http://subtextual.org/demo1.html) demo and talk, Edwards presents a live programming environment of a simple dynamic language.\r\n\r\nIn his [Subtext 2](http://www.subtext-lang.org/subtext2.html) demo, Edwards presents an inspiring way to edit canonical representations of conditional and type-dispatch code.\r\n\r\nThe Subtext project was the main inspiration for the Lamdu project.\r\n\r\n## Other related links\r\n\r\n* [We're doing it all wrong](http://www.youtube.com/watch?v=TS1lpKBMkgg) by Paul Phillips: Paul describes his frustrations with Scala and programming general, and describes a vision we believe overlaps with the Lamdu project greatly.\r\n\r\n* [Functional programs that explain their work](http://www.youtube.com/watch?v=pqtqaL_ojpk&feature=plcp).\r\n","google":"Lamdu","note":"Don't delete this file! It's used internally to help with page regeneration."}